        -:    0:Source:C:/Users/eckha/AtmelStudio/DwarfOS/DwarfOS/src/time.c
        -:    0:Graph:C:\Users\eckha\AtmelStudio\DwarfOS\DwarfOS\tests\standard-gcc\cmake-build-test-time\CMakeFiles\DwarfOS-test_Time.dir\_time.c.gcno
        -:    0:Data:C:\Users\eckha\AtmelStudio\DwarfOS\DwarfOS\tests\standard-gcc\cmake-build-test-time\CMakeFiles\DwarfOS-test_Time.dir\_time.c.gcda
        -:    0:Runs:1
        -:    1:#include <dwarf-os/time.h>
        -:    2:#include <dwarf-os/ascii_helper.h>
        -:    3:
        -:    4:uint32_t (* takeTimeFromClock)(void) = NULL;
        -:    5:
        -:    6://helper functions
        -:    7:uint16_t calcYear(uint32_t * days);
        -:    8:
        -:    9:uint8_t daysInMonth(uint16_t year, uint8_t month);
        -:   10:
        -:   11:uint8_t calcUtcOffset(uint32_t epochTimeY2K);
        -:   12:
        -:   13:uint8_t calcMonth(uint32_t * days, uint16_t year);
        -:   14:
        -:   15:uint8_t isDst(uint16_t year, uint8_t month, uint8_t day);
        -:   16:
        -:   17:uint8_t calcZellerCongruence(uint16_t year, uint8_t month, uint8_t day);
        -:   18:
        -:   19:uint8_t isLeapYear(uint16_t year);
        -:   20:
        -:   21:void formatString(char * resultString, struct tm * timeStructPtr);
        -:   22:
        -:   23:void addTimezone(char * result, uint8_t timezoneFlag);
        -:   24:
        -:   25://expecting no mcu library use this function, because it is per default unknown in a mcu environment without rtc
        -:   26://calculate this value with systemClock and CLOCKS_PER_SECOND or F_CPU in mcuClock if necessary and subtract the sleep times
        -:   27:// to keep this implementation as close as possible to the ansi/iso 9899-1990. After implementation connect it to the version in time.h
function clock called 0 returned 0% blocks executed 0%
    #####:   28:uint32_t clock(void) {
    #####:   29:    return -1;
    %%%%%:   29-block  0
        -:   30:}
        -:   31:
        -:   32://time1 - time0
function difftime called 0 returned 0% blocks executed 0%
    #####:   33:int32_t difftime(uint32_t time1, uint32_t time0) {
        -:   34:
        -:   35:    // 0 - uint32_t_max exceeds max negative values of int32_T, avoid the operation
    #####:   36:    int64_t diff = (int64_t) time1 - (int64_t) time0;
        -:   37:    //return INT32_MIN if we exceed its boundary
    #####:   38:    return (diff < INT32_MIN) ? INT32_MIN : (int32_t) diff;
    %%%%%:   38-block  0
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:   38-block  1
    %%%%%:   38-block  2
    %%%%%:   38-block  3
        -:   39:}
        -:   40:
        -:   41:// Converts the given year, month, day, hour, minute, and second into seconds since the epoch
function mktime called 3 returned 100% blocks executed 100%
        3:   42:uint32_t mktime(const struct tm * timeptr) {
        3:   43:    const struct tm time = (*timeptr);
        -:   44:
        -:   45:    // Calculate number of days since the epoch
        3:   46:    uint16_t daysSinceEpoch = (time.tm_year - EPOCH_YEAR) * 365;
        -:   47:
        -:   48:    // add one day for leap years
       45:   49:    for (uint16_t y = EPOCH_YEAR; y < time.tm_year; y++) {
        3:   49-block  0
       42:   49-block  1
       45:   49-block  2
branch  0 taken 42
branch  1 taken 3 (fallthrough)
       42:   50:        if (isLeapYear(y)) { daysSinceEpoch++; }
       42:   50-block  0
call    0 returned 42
branch  1 taken 12 (fallthrough)
branch  2 taken 30
       12:   50-block  1
        -:   51:    }
        -:   52:
       10:   53:    for (uint8_t m = 1; m < time.tm_mon; m++) { daysSinceEpoch += daysInMonth(time.tm_year, m); }
        3:   53-block  0
        7:   53-block  1
call    0 returned 7
       10:   53-block  2
branch  1 taken 7
branch  2 taken 3 (fallthrough)
        -:   54:
        3:   55:    uint32_t secondsSinceEpoch = daysSinceEpoch * ONE_DAY;
        3:   56:    secondsSinceEpoch += (time.tm_mday - 1) * ONE_DAY;
        3:   57:    secondsSinceEpoch += time.tm_hour * ONE_HOUR;
        3:   58:    secondsSinceEpoch += time.tm_min * 60;
        3:   59:    secondsSinceEpoch += time.tm_sec;
        -:   60:
        3:   61:    return secondsSinceEpoch;
        3:   61-block  0
        -:   62:}
        -:   63:
function isLeapYear called 317 returned 100% blocks executed 100%
      317:   64:uint8_t isLeapYear(uint16_t year) {
      317:   65:    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
      317:   65-block  0
branch  0 taken 88 (fallthrough)
branch  1 taken 229
       88:   65-block  1
branch  2 taken 16 (fallthrough)
branch  3 taken 72
      245:   65-block  2
branch  4 taken 16 (fallthrough)
branch  5 taken 229
       88:   65-block  3
      229:   65-block  4
      317:   65-block  5
        -:   66:}
        -:   67:
function time called 0 returned 0% blocks executed 0%
    #####:   68:uint32_t time(uint32_t * timer) {
    #####:   69:    uint32_t timestamp = 0;
        -:   70:
    #####:   71:    if (takeTimeFromClock != NULL) {
    %%%%%:   71-block  0
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:   72:        timestamp = takeTimeFromClock();
    %%%%%:   72-block  0
call    0 never executed
    #####:   73:        if (timer != NULL) { (*timer) = timestamp; }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:   73-block  0
    #####:   74:    } else if (timer != NULL) {
    %%%%%:   74-block  0
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:   75:        timestamp = (*timer);
    %%%%%:   75-block  0
        -:   76:    }
    #####:   77:    return timestamp;
    %%%%%:   77-block  0
        -:   78:}
        -:   79:
function ctime called 0 returned 0% blocks executed 0%
    #####:   80:char * ctime(uint32_t * timer) {
    #####:   81:    uint32_t timestamp = time(timer);
    %%%%%:   81-block  0
call    0 never executed
    #####:   82:    struct tm * timePointer = localtime(&timestamp);
call    0 never executed
    #####:   83:    char * result = asctime(timePointer);
call    0 never executed
    #####:   84:    free(timePointer);
    #####:   85:    return result;
        -:   86:}
        -:   87:
function asctime called 3 returned 100% blocks executed 91%
        3:   88:char * asctime(struct tm * timeptr) {
        3:   89:    char * result = (char *) malloc(TIMESTAMP_LENGTH * sizeof(char));
       3*:   90:    if (result == NULL) { return NULL; }
        3:   90-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:   90-block  1
        -:   91:
        3:   92:    formatString(result, timeptr);
        3:   92-block  0
call    0 returned 3
        3:   93:    switch (timeptr->tm_isdst) {
branch  0 taken 1
branch  1 taken 1
branch  2 taken 1
branch  3 taken 0
        1:   94:        case 1: {
        -:   95:            //CAVE: intended change of meanings for more efficient operations
        1:   96:            addTimezone(result, 2);
        1:   96-block  0
call    0 returned 1
        1:   97:            break;
        -:   98:        }
        1:   99:        case 2: {
        1:  100:            addTimezone(result, 1);
        1:  100-block  0
call    0 returned 1
        1:  101:            break;
        -:  102:        }
        1:  103:        case 0: {
        1:  104:            addTimezone(result, 0);
        1:  104-block  0
call    0 returned 1
        -:  105:        }
        3:  106:        default:;
        -:  107:    }
        -:  108:    // null terminate the string
        3:  109:    result[25] = '\0';
        3:  110:    return result;
        3:  110-block  0
        -:  111:}
        -:  112:
        -:  113:// CAVE: The meaning is now shifted for more efficient bit operation, flag 0 still UTC, but Flag 1 CEST now, Flag 2 CEST
function addTimezone called 3 returned 100% blocks executed 100%
        3:  114:void addTimezone(char * result, uint8_t timezoneFlag) {
        3:  115:    uint8_t adjustment = timezoneFlag & 1;
        3:  116:    uint8_t index = 20 - adjustment; //will shift the position on to the left for CEST
        -:  117:
        -:  118:    // (
        3:  119:    result[index++] = 0x28;
        3:  120:    if (!timezoneFlag) {
        3:  120-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        -:  121:        // U
        1:  122:        result[index++] = 0x55;
        1:  123:        result[index++] = 0x54;
        -:  124:        // C
        1:  125:        result[index++] = 0x43;
        1:  125-block  0
        -:  126:    } else {
        2:  127:        result[index++] = 0x43;
        2:  128:        result[index++] = 0x45;
        2:  129:        if (adjustment) {
        2:  129-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -:  130:            //S
        1:  131:            result[index++] = 0x53;
        1:  131-block  0
        -:  132:        }
        2:  133:        result[index++] = 0x54;
        2:  133-block  0
        -:  134:    }
        -:  135:    // )
        3:  136:    result[index++] = 0x29;
        3:  137:}
        -:  138:
function formatString called 3 returned 100% blocks executed 100%
        3:  139:void formatString(char * resultString, struct tm * timeStructPtr) {
        3:  140:    AsciiHelper * helper = dOS_initAsciiHelper();
        3:  140-block  0
call    0 returned 3
        3:  141:    if (helper != NULL) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  142:        helper->integerToAscii(resultString, timeStructPtr->tm_year, 4, 0);
        3:  142-block  0
call    0 returned 3
        3:  143:        helper->integerToAscii(resultString, timeStructPtr->tm_mon, 2, 5);
call    0 returned 3
        3:  144:        helper->integerToAscii(resultString, timeStructPtr->tm_mday, 2, 8);
call    0 returned 3
        3:  145:        helper->integerToAscii(resultString, timeStructPtr->tm_hour, 2, 11);
call    0 returned 3
        3:  146:        helper->integerToAscii(resultString, timeStructPtr->tm_min, 2, 14);
call    0 returned 3
        3:  147:        helper->integerToAscii(resultString, timeStructPtr->tm_sec, 2, 17);
call    0 returned 3
        -:  148:        // -
        3:  149:        resultString[4] = resultString[7] = 0x2d;
        -:  150:        //whitespace
        3:  151:        resultString[10] = 0x20;
        -:  152:        // :
        3:  153:        resultString[13] = resultString[16] = 0x3a;
        -:  154:        // whitespace
        3:  155:        resultString[19] = 0x20;
        -:  156:    }
        3:  157:    free(helper);
        3:  158:}
        -:  159:
function gmtime called 2 returned 100% blocks executed 86%
        2:  160:struct tm * gmtime(const uint32_t * timer) {
        -:  161:
        2:  162:    struct tm * constructedTime = (struct tm *) malloc(sizeof(struct tm));
       2*:  163:    if (constructedTime == NULL) { return NULL; }
        2:  163-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  163-block  1
        -:  164:
        2:  165:    uint32_t timeValue = (*timer);
        -:  166:
        2:  167:    constructedTime->tm_sec = timeValue % 60;
        2:  168:    timeValue /= 60;
        2:  169:    constructedTime->tm_min = timeValue % 60;
        2:  170:    timeValue /= 60;
        2:  171:    constructedTime->tm_hour = timeValue % 24;
        2:  172:    timeValue /= 24;
        2:  173:    constructedTime->tm_year = calcYear(&timeValue);
        2:  173-block  0
call    0 returned 2
        2:  174:    constructedTime->tm_mon = calcMonth(&timeValue, constructedTime->tm_year);
call    0 returned 2
        2:  175:    constructedTime->tm_mday = timeValue + 1; // Days start from 0, so add 1
        -:  176:
        2:  177:    return constructedTime;
        -:  178:}
        -:  179:
function localtime called 2 returned 100% blocks executed 100%
        2:  180:struct tm * localtime(const uint32_t * timer) {
        2:  181:    uint32_t adjusted = (*timer);
        2:  182:    uint8_t utcOffset = calcUtcOffset(adjusted);
        2:  182-block  0
call    0 returned 2
        -:  183:    // Adjust for UTC offset
        2:  184:    adjusted += utcOffset * ONE_HOUR;
        2:  185:    struct tm * timeToReturn = gmtime(&adjusted);
call    0 returned 2
        -:  186:
        2:  187:    timeToReturn->tm_isdst = utcOffset;
        2:  188:    return timeToReturn;
        -:  189:}
        -:  190:
function strftime called 0 returned 0% blocks executed 0%
    #####:  191:size_t strftime(char * s, size_t maxsize, const char * format, const struct tm * timeptr) {
    #####:  192:    return 0;
    %%%%%:  192-block  0
        -:  193:}
        -:  194:
        -:  195://time1 - time0
function difftime_unsigned called 0 returned 0% blocks executed 0%
    #####:  196:uint32_t difftime_unsigned(uint32_t time1, uint32_t time0) {
        -:  197:
    #####:  198:    int64_t diff = (int64_t) time1 - (int64_t) time0;
    #####:  199:    return (uint32_t) (diff >= 0 ? diff : -diff);
    %%%%%:  199-block  0
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  199-block  1
    %%%%%:  199-block  2
    %%%%%:  199-block  3
        -:  200:}
        -:  201:
function setMcuClockCallback called 0 returned 0% blocks executed 0%
    #####:  202:void setMcuClockCallback(uint32_t (* mcuClockCallback)(void)) {
    #####:  203:    takeTimeFromClock = mcuClockCallback;
    #####:  204:}
        -:  205:
        -:  206:// Returns the number of days in a given month of a given year
function daysInMonth called 64 returned 100% blocks executed 100%
       64:  207:uint8_t daysInMonth(uint16_t year, uint8_t month) {
        -:  208:
        -:  209:    static const uint8_t days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
       64:  210:    uint8_t daysInMonth = days[month - 1];
        -:  211:
       64:  212:    if (month == 2 && isLeapYear(year)) { daysInMonth++; }
       64:  212-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 50
       14:  212-block  1
call    2 returned 14
branch  3 taken 2 (fallthrough)
branch  4 taken 12
        2:  212-block  2
        -:  213:
       64:  214:    return daysInMonth;
       64:  214-block  0
        -:  215:}
        -:  216:
function calcZellerCongruence called 7 returned 100% blocks executed 67%
        7:  217:uint8_t calcZellerCongruence(uint16_t year, uint8_t month, uint8_t day) {
        -:  218:    uint32_t h;
        7:  219:    if (month == 1) {
        7:  219-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  220:        month = 13;
    #####:  221:        year--;
    %%%%%:  221-block  0
        -:  222:    }
        7:  223:    if (month == 2) {
        7:  223-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  224:        month = 14;
    #####:  225:        year--;
    %%%%%:  225-block  0
        -:  226:    }
        7:  227:    h = day + 13 * (month + 1) / 5 + (year % 100) + (year % 100) / 4 + (year / 100) / 4 + 5 * (year / 100);
        7:  228:    h = h % 7;
        7:  229:    return h;
        7:  229-block  0
        -:  230:}
        -:  231:
function isDst called 9 returned 100% blocks executed 100%
        9:  232:uint8_t isDst(uint16_t year, uint8_t month, uint8_t day) {
        9:  233:    if (month > 3 && month < 10) { return 1; }
        9:  233-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 4
        5:  233-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 2
        3:  233-block  2
        6:  234:    if (month < 3 || month > 10) { return 0; }
        6:  234-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 2
        4:  234-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        2:  234-block  2
        -:  235:
        4:  236:    uint8_t lastDayOfMonth = calcZellerCongruence(year, month, 31);
        4:  236-block  0
call    0 returned 4
        4:  237:    uint8_t lastSunday = 31 - ((lastDayOfMonth - 1) % 7);
        -:  238:
        4:  239:    if ((day >= lastSunday && month == 3) || (day < lastSunday && month == 10)) { return 1; }
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  239-block  0
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        3:  239-block  1
branch  4 taken 2 (fallthrough)
branch  5 taken 1
        2:  239-block  2
branch  6 taken 1 (fallthrough)
branch  7 taken 1
        2:  239-block  3
        2:  240:    return 0;
        2:  240-block  0
        -:  241:}
        -:  242:
function calcYear called 7 returned 100% blocks executed 100%
        7:  243:uint16_t calcYear(uint32_t * days) {
        7:  244:    uint16_t year = EPOCH_YEAR;
      134:  245:    while ((*days) >= (uint16_t) 365 + isLeapYear(year)) {
        7:  245-block  0
      134:  245-block  1
call    0 returned 134
branch  1 taken 127
branch  2 taken 7 (fallthrough)
      127:  246:        if (isLeapYear(year)) {
      127:  246-block  0
call    0 returned 127
branch  1 taken 37 (fallthrough)
branch  2 taken 90
       37:  247:            (*days) -= 366;
       37:  248:            year++;
       37:  248-block  0
        -:  249:        } else {
       90:  250:            (*days) -= 365;
       90:  251:            year++;
       90:  251-block  0
        -:  252:        }
        -:  253:    }
        7:  254:    return year;
        7:  254-block  0
        -:  255:}
        -:  256:
function calcMonth called 8 returned 100% blocks executed 100%
        8:  257:uint8_t calcMonth(uint32_t * days, uint16_t year) {
        8:  258:    uint8_t month = 1;
       32:  259:    while ((*days) >= daysInMonth(year, month)) {
        8:  259-block  0
       32:  259-block  1
call    0 returned 32
branch  1 taken 24
branch  2 taken 8 (fallthrough)
       24:  260:        (*days) -= daysInMonth(year, month);
       24:  260-block  0
call    0 returned 24
       24:  261:        month++;
        -:  262:    }
        8:  263:    return month;
        8:  263-block  0
        -:  264:}
        -:  265:
function calcUtcOffset called 4 returned 100% blocks executed 100%
        4:  266:uint8_t calcUtcOffset(uint32_t epochTimeY2K) {
        4:  267:    uint32_t days = epochTimeY2K /= ONE_DAY;
        4:  268:    uint16_t year = calcYear(&days);
        4:  268-block  0
call    0 returned 4
        4:  269:    uint8_t month = calcMonth(&days, year);
call    0 returned 4
        -:  270:    // Days start from 0, so add 1
        4:  271:    uint8_t day = days + 1;
        4:  272:    return isDst(year, month, day) ? 2 : 1;
call    0 returned 4
branch  1 taken 2 (fallthrough)
branch  2 taken 2
        2:  272-block  0
        2:  272-block  1
        4:  272-block  2
        -:  273:}

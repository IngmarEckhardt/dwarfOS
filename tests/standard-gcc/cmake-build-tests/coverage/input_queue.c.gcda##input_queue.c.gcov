        -:    0:Source:C:/Users/eckha/AtmelStudio/DwarfOS/DwarfOS/src/input_queue.c
        -:    0:Graph:C:\Users\eckha\AtmelStudio\DwarfOS\DwarfOS\tests\standard-gcc\cmake-build-tests\CMakeFiles\DwarfOS-testLibInputQueueReduced.dir\C_\Users\eckha\AtmelStudio\DwarfOS\DwarfOS\src\input_queue.c.gcno
        -:    0:Data:C:\Users\eckha\AtmelStudio\DwarfOS\DwarfOS\tests\standard-gcc\cmake-build-tests\CMakeFiles\DwarfOS-testLibInputQueueReduced.dir\C_\Users\eckha\AtmelStudio\DwarfOS\DwarfOS\src\input_queue.c.gcda
        -:    0:Runs:1
        -:    1:#include <dwarf-os/input_queue.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:
        -:    5:
        -:    6:void increaseSize(InputQueue * inputQueue);
        -:    7:
        -:    8:void decreaseSize(InputQueue * inputQueue);
        -:    9:
        -:   10:uint8_t countElementsInQueue(InputQueue * inputQueue);
        -:   11:
function enqueue called 800 returned 100% blocks executed 100%
      800:   12:void enqueue(uint8_t item, InputQueue * inputQueue) {
        -:   13:
      800:   14:    uint8_t nextTail = (inputQueue->tail + 1) % inputQueue->size;
      800:   15:    if (nextTail == inputQueue->head) {
      800:   15-block  0
branch  0 taken 54 (fallthrough)
branch  1 taken 746
       54:   16:        uint8_t oldSize = inputQueue->size;
       54:   17:        increaseSize(inputQueue);
       54:   17-block  0
call    0 returned 54
       54:   18:        if (inputQueue->size > oldSize) {
branch  0 taken 23 (fallthrough)
branch  1 taken 31
       23:   19:            nextTail = (inputQueue->tail + 1) % inputQueue->size;
       23:   19-block  0
        -:   20:        } else {
       31:   21:            return;
       31:   21-block  0
        -:   22:        }
        -:   23:    }
      769:   24:    inputQueue->buffer[inputQueue->tail] = item;
      769:   25:    inputQueue->tail = nextTail;
      769:   25-block  0
        -:   26:}
        -:   27:
function dequeue called 529 returned 100% blocks executed 100%
      529:   28:int16_t dequeue(InputQueue * inputQueue) {
        -:   29:
      529:   30:    if (inputQueue->head == inputQueue->tail) { return -1; }
      529:   30-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 527
        2:   30-block  1
      527:   31:    uint8_t item = inputQueue->buffer[inputQueue->head];
      527:   32:    inputQueue->buffer[inputQueue->head] = 0;
      527:   33:    inputQueue->head = (inputQueue->head + 1) % inputQueue->size;
        -:   34:
      527:   35:    if (inputQueue->size > INPUT_BUFFER_START_SIZE && countElementsInQueue(inputQueue) < inputQueue->size / 4) {
      527:   35-block  0
branch  0 taken 517 (fallthrough)
branch  1 taken 10
      517:   35-block  1
call    2 returned 517
branch  3 taken 16 (fallthrough)
branch  4 taken 501
       16:   36:        decreaseSize(inputQueue);
       16:   36-block  0
call    0 returned 16
        -:   37:    }
      527:   38:    return item;
      527:   38-block  0
        -:   39:}
        -:   40:
function getCharacter called 0 returned 0% blocks executed 0%
    #####:   41:int16_t getCharacter(InputQueue * inputQueue) {
    #####:   42:    int16_t nextChar = inputQueue->dequeue(inputQueue);
    %%%%%:   42-block  0
call    0 never executed
    #####:   43:    while (nextChar == -1) {
    %%%%%:   43-block  0
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:   44:        nextChar = inputQueue->dequeue(inputQueue);
    %%%%%:   44-block  0
call    0 never executed
        -:   45:    }
    #####:   46:    return nextChar;
    %%%%%:   46-block  0
        -:   47:}
        -:   48:
        -:   49:
function dOS_initInputQueue called 12 returned 100% blocks executed 67%
       12:   50:InputQueue * dOS_initInputQueue(void) {
       12:   51:    InputQueue * queue = malloc(sizeof(InputQueue));
      12*:   52:    if (queue == NULL) { return NULL; }
       12:   52-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    %%%%%:   52-block  1
        -:   53:    else {
       12:   54:        queue->head = 0;
       12:   55:        queue->tail = 0;
       12:   56:        queue->size = INPUT_BUFFER_START_SIZE;
       12:   57:        queue->buffer = malloc(INPUT_BUFFER_START_SIZE * sizeof(uint8_t));
       12:   58:        if (queue->buffer == NULL) {
       12:   58-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####:   59:            free(queue);
    #####:   60:            return NULL;
    %%%%%:   60-block  0
        -:   61:        }
       12:   62:        queue->enqueue = enqueue;
       12:   63:        queue->dequeue = dequeue;
       12:   64:        queue->get_char = getCharacter;
       12:   65:        return queue;
       12:   65-block  0
        -:   66:    }
        -:   67:}
        -:   68:
function increaseSize called 54 returned 100% blocks executed 88%
       54:   69:void increaseSize(InputQueue * inputQueue) {
       54:   70:    if (inputQueue->size >= UINT8_MAX / 2) {
       54:   70-block  0
branch  0 taken 31 (fallthrough)
branch  1 taken 23
       31:   71:        return;
       31:   71-block  0
        -:   72:    }
       23:   73:    uint8_t newSize = inputQueue->size * 2;
        -:   74:
       23:   75:    uint8_t * newBuffer = malloc(newSize * sizeof(uint8_t));
       23:   76:    if (newBuffer == NULL) {
       23:   76-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 23
    #####:   77:        return;
    %%%%%:   77-block  0
        -:   78:    } else {
       23:   79:        memcpy(newBuffer, inputQueue->buffer, inputQueue->tail);
        -:   80:    }
        -:   81:
       23:   82:    if (inputQueue->head > 0) {
       23:   82-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 18
        5:   83:        uint8_t amountOfBytesToMove = inputQueue->size - inputQueue->head;
        5:   84:        uint8_t newHead = (inputQueue->size + inputQueue->head);
        5:   85:        memcpy(newBuffer + newHead,
        5:   86:               inputQueue->buffer + inputQueue->head,
        -:   87:               amountOfBytesToMove);
        5:   88:        inputQueue->head = newHead;
        5:   88-block  0
        -:   89:    }
       23:   90:    inputQueue->size = newSize;
       23:   91:    free(inputQueue->buffer);
       23:   92:    inputQueue->buffer = newBuffer;
       23:   92-block  0
        -:   93:}
        -:   94:
function decreaseSize called 16 returned 100% blocks executed 78%
       16:   95:void decreaseSize(InputQueue * inputQueue) {
       16:   96:    if (inputQueue->size < INPUT_BUFFER_START_SIZE * 2) {
       16:   96-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    #####:   97:        return;
    %%%%%:   97-block  0
        -:   98:    }
       16:   99:    uint8_t newSize = inputQueue->size / 2;
        -:  100:
       16:  101:    uint8_t * newBuffer = malloc(newSize * sizeof(uint8_t));
      16*:  102:    if (newBuffer == NULL) { return; }
       16:  102-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    %%%%%:  102-block  1
        -:  103:
       16:  104:    if (inputQueue->tail > inputQueue->head) {
       16:  104-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 2
       14:  105:        uint8_t amountOfBytesToMove = inputQueue->tail - inputQueue->head;
        -:  106:
       14:  107:        memcpy(newBuffer,
       14:  108:               inputQueue->buffer + inputQueue->head,
        -:  109:               amountOfBytesToMove);
       14:  110:        inputQueue->head = 0;
       14:  111:        inputQueue->tail = amountOfBytesToMove;
       14:  111-block  0
        -:  112:    } else {
        2:  113:        uint8_t amountOfBytesToMove = inputQueue->size - inputQueue->head;
        2:  114:        uint8_t newHead = newSize - amountOfBytesToMove;
        -:  115:
        2:  116:        memcpy(newBuffer + newHead,
        2:  117:               inputQueue->buffer + inputQueue->head,
        -:  118:               amountOfBytesToMove);
        2:  119:        inputQueue->head = newHead;
        2:  119-block  0
        -:  120:    }
       16:  121:    inputQueue->size = newSize;
       16:  122:    free(inputQueue->buffer);
       16:  123:    inputQueue->buffer = newBuffer;
       16:  123-block  0
        -:  124:}
        -:  125:
function countElementsInQueue called 517 returned 100% blocks executed 100%
      517:  126:uint8_t countElementsInQueue(InputQueue * inputQueue) {
      517:  127:    if (inputQueue->head <= inputQueue->tail) {
      517:  127-block  0
branch  0 taken 494 (fallthrough)
branch  1 taken 23
      494:  128:        return inputQueue->tail - inputQueue->head;
      494:  128-block  0
        -:  129:    } else {
       23:  130:        return inputQueue->size - inputQueue->head + inputQueue->tail;
       23:  130-block  0
        -:  131:    }
        -:  132:}
